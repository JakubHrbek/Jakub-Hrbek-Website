<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quick Sort | Algolt</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" />
  <link rel="stylesheet" href="algorithm.css" />
</head>
<body>
  <nav class="navbar sticky top-0 z-50">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex justify-between items-center h-16">
        <div class="flex items-center space-x-8">
          <a href="../index.html" class="navbar-link text-sm font-medium text-gray-900 hover:text-blue-600">JH</a>
          <a href="../../algolt/index.html" class="navbar-link far-link text-sm font-medium text-gray-900 hover:text-blue-600">Home</a>
        </div>
        <div class="flex items-center">
          <span class="text-sm font-medium text-gray-600">Quick Sort</span>
        </div>
      </div>
    </div>
  </nav>

  <header class="px-4 md:px-6 py-12 border-b border-gray-200 bg-white">
    <div class="max-w-7xl mx-auto">
      <h1 class="text-3xl md:text-4xl font-bold text-gray-900 mb-3">
        Quick Sort Visualizer
      </h1>
      <p class="text-lg text-gray-600 max-w-2xl">
        Interactive visualization of the quick sort algorithm with step-by-step execution and performance metrics.
      </p>
    </div>
  </header>

  <main class="max-w-7xl mx-auto p-4 md:p-6 space-y-12">
    <section class="grid grid-cols-1 lg:grid-cols-3 gap-8">
      <div class="lg:col-span-2 space-y-6">
        <div class="visualizer-card card p-6">
          <div id="visualizer" class="flex items-end justify-center h-[280px] md:h-[320px] overflow-hidden"></div>
        </div>
        
        <div class="card p-6">
          <div class="control-buttons flex flex-wrap gap-3 mb-6">
            <button id="playBtn" class="btn btn-primary px-6 py-3">Play</button>
            <button id="pauseBtn" class="btn btn-primary px-6 py-3">Pause</button>
            <button id="stepBtn" class="btn btn-primary px-6 py-3">Step</button>
            <button id="resetBtn" class="btn btn-secondary px-6 py-3">Reset</button>
          </div>
          
          <div class="stats-grid">
            <div class="stat-item">
              <div class="stat-label">Timer</div>
              <div id="timer" class="stat-value mono">0.00s</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Comparisons</div>
              <div id="comparisons" class="stat-value mono">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Swaps</div>
              <div id="swaps" class="stat-value mono">0</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Depth</div>
              <div id="depth" class="stat-value mono">0</div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="lg:col-span-1">
        <div class="code-block h-full">
          <pre><code class="language-js">// Quick Sort Algorithm
function quickSort(arr, low = 0, high = arr.length - 1) {
  if (low < high) {
    const pivotIndex = partition(arr, low, high);
    
    quickSort(arr, low, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, high);
  }
  return arr;
}

function partition(arr, low, high) {
  const pivot = arr[high];
  let i = low - 1;
  
  for (let j = low; j < high; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  
  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
  return i + 1;
}</code></pre>
        </div>
      </div>
    </section>

    <section class="card p-6">
      <h2 class="section-title">Custom Input</h2>
      <p class="text-gray-600 mb-4">Enter your own array of numbers to visualize the sorting process.</p>
      <div class="flex flex-col sm:flex-row gap-3">
        <div class="input-group flex-1">
          <input id="customInput" class="input-field" placeholder="Enter comma-separated numbers (e.g. 64,34,25,12,22,11,90)" />
        </div>
        <button id="loadCustom" class="btn btn-primary px-6 py-3 whitespace-nowrap">Load Array</button>
      </div>
    </section>

    <section class="grid grid-cols-1 md:grid-cols-2 gap-8">
      <div class="card p-6">
        <h2 class="section-title">How It Works</h2>
        <p class="text-gray-700 leading-relaxed">
          Quick Sort uses a divide-and-conquer strategy. It selects a 'pivot' element and partitions the array so that elements smaller than the pivot come before it, and elements greater come after. This process is recursively applied to sub-arrays.
        </p>
      </div>
      
      <div class="card p-6">
        <h2 class="section-title">Key Characteristics</h2>
        <ul class="space-y-2 text-gray-700">
          <li class="flex items-start">
            <span class="text-blue-600 mr-2">•</span>
            <span><strong>Unstable:</strong> Equal elements may change relative order</span>
          </li>
          <li class="flex items-start">
            <span class="text-blue-600 mr-2">•</span>
            <span><strong>In-place:</strong> Sorts with O(log n) extra space</span>
          </li>
          <li class="flex items-start">
            <span class="text-blue-600 mr-2">•</span>
            <span><strong>Divide & Conquer:</strong> Recursively partitions the array</span>
          </li>
        </ul>
      </div>
    </section>
    
    <section class="card p-6">
      <h2 class="section-title">Time & Space Complexity</h2>
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <div>
          <h3 class="text-lg font-semibold mb-4 text-gray-800">Quick Sort Analysis</h3>
          <div class="space-y-3">
            <div class="flex justify-between items-center py-2 border-b border-gray-100">
              <span class="font-medium text-gray-700">Best Case:</span>
              <span class="mono text-green-600 font-semibold">O(n log n)</span>
            </div>
            <div class="flex justify-between items-center py-2 border-b border-gray-100">
              <span class="font-medium text-gray-700">Average Case:</span>
              <span class="mono text-yellow-600 font-semibold">O(n log n)</span>
            </div>
            <div class="flex justify-between items-center py-2 border-b border-gray-100">
              <span class="font-medium text-gray-700">Worst Case:</span>
              <span class="mono text-red-600 font-semibold">O(n²)</span>
            </div>
            <div class="flex justify-between items-center py-2">
              <span class="font-medium text-gray-700">Space:</span>
              <span class="mono text-blue-600 font-semibold">O(log n)</span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="quiz-card" id="quiz-section">
      <h2 class="section-title">Test Your Knowledge</h2>
      <div id="quiz-container"></div>
    </section>

    <section class="card p-6 text-center">
      <a href="./merge-sort.html" class="inline-flex items-center text-blue-600 hover:text-blue-700 font-medium transition-colors">
        Next: Merge Sort 
        <svg class="ml-2 w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
        </svg>
      </a>
    </section>
  </main>

  <!-- Include the external quiz system -->
  <script src="quiz.js"></script>
  
  <script>
    // Quick Sort Visualizer Logic
    const visualizer = document.getElementById("visualizer");
    const playBtn = document.getElementById("playBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const stepBtn = document.getElementById("stepBtn");
    const resetBtn = document.getElementById("resetBtn");
    const loadCustom = document.getElementById("loadCustom");
    const input = document.getElementById("customInput");
    const timerDisplay = document.getElementById("timer");
    const comparisonsDisplay = document.getElementById("comparisons");
    const swapsDisplay = document.getElementById("swaps");
    const depthDisplay = document.getElementById("depth");

    let values = [], bars = [], originalValues = [];
    let comparisons = 0, swaps = 0, maxDepth = 0, currentDepth = 0;
    let isPlaying = false, isPaused = false, isComplete = false;
    let startTime, elapsedTime = 0, timerInterval;
    let sortingSteps = [], currentStep = 0;

    function updateStats() {
      comparisonsDisplay.innerText = comparisons;
      swapsDisplay.innerText = swaps;
      depthDisplay.innerText = maxDepth;
    }

    function getOptimalArraySize() {
      const isMobile = window.innerWidth <= 768;
      return isMobile ? 15 : 20;
    }

    function generateBars(custom = null) {
      const arraySize = getOptimalArraySize();
      originalValues = custom || Array.from({ length: arraySize }, () => Math.floor(Math.random() * 90) + 10);
      values = [...originalValues];
      
      if (window.innerWidth <= 768 && values.length > 15) {
        values = values.slice(0, 15);
        originalValues = [...values];
      }
      
      visualizer.innerHTML = "";
      bars = values.map((value, index) => {
        const bar = document.createElement("div");
        bar.classList.add("bar");
        bar.dataset.index = index;
        const maxHeight = window.innerWidth <= 768 ? 220 : 260;
        const height = Math.min((value / 100) * maxHeight, maxHeight);
        bar.style.height = `${height}px`;
        bar.style.position = "relative";
        visualizer.appendChild(bar);
        return bar;
      });
      
      comparisons = 0; swaps = 0; maxDepth = 0; currentDepth = 0; elapsedTime = 0;
      isComplete = false; currentStep = 0; sortingSteps = [];
      timerDisplay.innerText = "0.00s";
      updateStats();
      
      // Generate sorting steps
      generateQuickSortSteps();
      
      playBtn.disabled = false;
      playBtn.textContent = "Play";
      pauseBtn.textContent = "Pause";
      isPaused = false;
      isPlaying = false;
    }

    function generateQuickSortSteps() {
      const arr = [...values];
      sortingSteps = [];
      
      function quickSortSteps(arr, low, high, depth = 0) {
        if (low < high) {
          maxDepth = Math.max(maxDepth, depth);
          
          // Partition step
          const pivotIndex = partitionSteps(arr, low, high, depth);
          
          // Recursive calls
          quickSortSteps(arr, low, pivotIndex - 1, depth + 1);
          quickSortSteps(arr, pivotIndex + 1, high, depth + 1);
        }
      }
      
      function partitionSteps(arr, low, high, depth) {
        const pivot = arr[high];
        let i = low - 1;
        
        // Mark pivot
        sortingSteps.push({
          type: 'pivot',
          pivot: high,
          low: low,
          high: high,
          depth: depth,
          array: [...arr]
        });
        
        for (let j = low; j < high; j++) {
          // Compare step
          sortingSteps.push({
            type: 'compare',
            comparing: [j, high],
            i: i,
            j: j,
            pivot: high,
            low: low,
            high: high,
            depth: depth,
            array: [...arr]
          });
          
          if (arr[j] <= pivot) {
            i++;
            if (i !== j) {
              // Swap step
              [arr[i], arr[j]] = [arr[j], arr[i]];
              sortingSteps.push({
                type: 'swap',
                swapping: [i, j],
                pivot: high,
                low: low,
                high: high,
                depth: depth,
                array: [...arr]
              });
            }
          }
        }
        
        // Final pivot swap
        [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
        sortingSteps.push({
          type: 'pivot_final',
          swapping: [i + 1, high],
          pivotIndex: i + 1,
          low: low,
          high: high,
          depth: depth,
          array: [...arr]
        });
        
        return i + 1;
      }
      
      quickSortSteps(arr, 0, arr.length - 1);
      
      // Add completion step
      sortingSteps.push({
        type: 'complete',
        array: [...arr]
      });
    }

    function startTimer() {
      startTime = Date.now() - elapsedTime * 1000;
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (!isPaused) {
          elapsedTime = (Date.now() - startTime) / 1000;
          timerDisplay.innerText = `${elapsedTime.toFixed(2)}s`;
        }
      }, 10);
    }

    function resetBarColors() {
      bars.forEach(bar => {
        bar.classList.remove('comparing', 'sorted', 'pivot', 'swapping');
        bar.style.backgroundColor = '';
      });
    }

    function updateVisualization(step) {
      resetBarColors();
      
      // Update bar heights based on current array state
      step.array.forEach((value, index) => {
        const maxHeight = window.innerWidth <= 768 ? 220 : 260;
        const height = Math.min((value / 100) * maxHeight, maxHeight);
        bars[index].style.height = `${height}px`;
      });
      
      switch (step.type) {
        case 'pivot':
          bars[step.pivot].classList.add('pivot');
          if (step.low !== undefined && step.high !== undefined) {
            for (let i = step.low; i <= step.high; i++) {
              if (i !== step.pivot) {
                bars[i].style.backgroundColor = 'rgba(59, 130, 246, 0.2)';
              }
            }
          }
          break;
          
        case 'compare':
          step.comparing.forEach(index => {
            bars[index].classList.add('comparing');
          });
          comparisons++;
          break;
          
        case 'swap':
        case 'pivot_final':
          step.swapping.forEach(index => {
            bars[index].classList.add('swapping');
          });
          swaps++;
          break;
          
        case 'complete':
          bars.forEach(bar => bar.classList.add('sorted'));
          break;
      }
      
      if (step.depth !== undefined) {
        maxDepth = Math.max(maxDepth, step.depth);
      }
      
      updateStats();
    }

    async function sortStep() {
      if (currentStep >= sortingSteps.length) {
        isComplete = true;
        clearInterval(timerInterval);
        resetBarColors();
        bars.forEach(bar => bar.classList.add('sorted'));
        playBtn.textContent = "Complete";
        playBtn.disabled = true;
        return;
      }

      const step = sortingSteps[currentStep];
      updateVisualization(step);
      
      const delay = window.innerWidth <= 768 ? 300 : 200;
      await new Promise(r => setTimeout(r, delay));
      
      currentStep++;
    }

    async function quickSortLoop() {
      startTimer();
      while (currentStep < sortingSteps.length && isPlaying && !isPaused && !isComplete) {
        await sortStep();
      }
      if (isComplete) {
        clearInterval(timerInterval);
      }
    }

    playBtn.onclick = () => {
      if (!isPlaying && !isComplete) {
        isPlaying = true;
        isPaused = false;
        playBtn.textContent = "Playing...";
        quickSortLoop();
      }
    };

    pauseBtn.onclick = () => {
      if (isComplete) return;
      
      isPaused = !isPaused;
      if (!isPaused && isPlaying) {
        quickSortLoop();
        pauseBtn.textContent = "Pause";
        playBtn.textContent = "Playing...";
      } else {
        pauseBtn.textContent = "Resume";
        playBtn.textContent = "Play";
      }
    };

    stepBtn.onclick = async () => {
      if (!isComplete) {
        isPlaying = false;
        isPaused = true;
        playBtn.textContent = "Play";
        pauseBtn.textContent = "Pause";
        await sortStep();
      }
    };

    resetBtn.onclick = () => {
      isPaused = true;
      isPlaying = false;
      isComplete = false;
      clearInterval(timerInterval);
      generateBars(originalValues);
    };

    loadCustom.onclick = () => {
      const nums = input.value.split(',')
        .map(n => parseInt(n.trim()))
        .filter(n => !isNaN(n) && n > 0)
        .map(n => Math.min(n, 100));
      
      if (nums.length > 1) {
        const maxSize = window.innerWidth <= 768 ? 15 : 25;
        const limitedNums = nums.slice(0, maxSize);
        generateBars(limitedNums);
        input.value = '';
      } else {
        alert('Please enter at least 2 valid numbers separated by commas.');
      }
    };

    window.addEventListener('resize', () => {
      generateBars(originalValues);
    });

    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        loadCustom.click();
      }
    });

    // Initialize the visualizer
    generateBars();

    // Quiz Data for Quick Sort
    const quickSortQuizData = [
      {
        question: "What is the average-case time complexity of Quick Sort?",
        options: ["O(n²)", "O(n log n)", "O(n)", "O(log n)"],
        answer: "O(n log n)",
        explanation: "On average, Quick Sort divides the array into roughly equal parts, leading to O(n log n) time complexity."
      },
      {
        question: "What causes Quick Sort's worst-case performance?",
        options: [
          "When the array contains duplicates",
          "When the pivot is always the smallest or largest element", 
          "When the array is randomly ordered",
          "When the array size is too large"
        ],
        answer: "When the pivot is always the smallest or largest element",
        explanation: "Worst case occurs when the pivot consistently results in highly unbalanced partitions, such as when the array is already sorted and we always choose the first or last element as pivot."
      },
      {
        question: "What is the space complexity of Quick Sort?",
        options: ["O(n)", "O(n²)", "O(log n)", "O(1)"],
        answer: "O(log n)",
        explanation: "Quick Sort uses O(log n) space on average due to the recursive call stack, though in the worst case it can be O(n)."
      },
      {
        question: "Which pivot selection strategy helps avoid worst-case performance?",
        options: [
          "Always choose the first element",
          "Always choose the last element",
          "Choose the median-of-three",
          "Choose a random element"
        ],
        answer: "Choose the median-of-three",
        explanation: "Median-of-three (choosing the median of first, middle, and last elements) helps avoid worst-case scenarios and generally provides better performance than fixed pivot selection."
      }
    ];

    // Initialize the quiz
    AlgorithmQuiz.create('quiz-container', quickSortQuizData);
  </script>
</body>
</html>